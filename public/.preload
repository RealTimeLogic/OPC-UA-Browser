tracep(false, 5, "Initializing OPCUA")
local ua = require("opcua.api")
local init = require("opcua.init")

local checkConfig = require("opcua.config")
local sock = require("socket")
local gettime=os.time

local function getHostName()
  local hostname
  if os and os.execute and os.execute() then
    local f = _G.io.popen("hostname")
    hostname = f:read("*a")
  else
    local sock = sock.connect("google.com", 80)
    local _,_,ips = string.find(sock:sockname(), "(%d+.%d+.%d+.%d+)")
    hostname = ips
  end

  hostname = string.gsub(hostname, "[\n\r]", "")
  return hostname
end

local function getDefaultCert(fileName)
  tracep(false, 5, "Use embedded OPCUA certificates")
  local keyPath = "."..fileName..".key"
  local certPath = "."..fileName..".pem"
  return certPath, keyPath, _ENV.app.io
end

local function writeFile(fio, fileName, data)
  local f, err = fio:open(fileName, "w")
  if err then
    trace(string.format("Failed to create file '%s': "..err))
    return false
  end

  local result = f:write(data)
  if not result then
    trace(string.format("Failed to save file '%s'." , fileName))
    return getDefaultCert(fileName)
  end

  f:close()

  return true
end

local function genOPCUACert(genFunc, hostname, applicationUri, fileName)
  local hio = ba.openio("home")
  if not hio then
    tracep(false, 5, "Cannot open homeio")
    return getDefaultCert(fileName)
  end

  if not hio:stat("cert") and not hio:mkdir("cert") then
    tracep(false, 5, "Cannot create directory "..hio:realpath("cert"))
    return getDefaultCert(fileName)
  end

  local cio = ba.mkio(hio, "cert")
  local keyName = fileName..".key"
  local certName = fileName..".pem"
  local keyHandle = cio:open(keyName)
  local certHandle = cio:open(certName)
  if not keyHandle or not certHandle then
    local cert, key = genFunc(hostname, applicationUri)
    if not writeFile(cio, certName, cert) then
      return getDefaultCert(fileName)
    end
    if not writeFile(cio, keyName, key)then
      return getDefaultCert(fileName)
    end
  end

  return cio:realpath(certName), cio:realpath(keyName)
end

-- Connect logging traces
-- Logging level is controlled by config file.
ua.trace.dbg = function(msg)
  tracep(false, 10, msg)
end

ua.trace.inf = function(msg)
  tracep(false, 9, msg)
end

ua.trace.err = function(msg)
  tracep(false, 0, msg)
end

local hostname = getHostName()

local makoConf=pcall(require, "loadconf")
if not makoConf then
  tracep(false, 5, "Cannot load mako.conf")
  makoConf = nil
end

---
--- OPCUA client
---

tracep(false, 5, "Creating OPCUA client")
-- Load and check client configuration file
local clientConfig = makoConf and makoConf.uaClient
if not clientConfig then
  tracep(false, 5, "Loading OPCUA client config from file '.opcua_client_config'")
  clientConfig = _ENV.app.io:dofile(".opcua_client_config", _ENV)
end

if not clientConfig.certificate then
  local certPath, keyPath, certIo = genOPCUACert(init.genClientCertificate, hostname, clientConfig.applicationUri, "opcua_client")
  clientConfig.certificate = certPath
  clientConfig.key = keyPath
  clientConfig.io = certIo
end

checkConfig.client(clientConfig)
_G.clientConfig = clientConfig


---
---  OPCUA server
---

local users = makoConf and makoConf.users
if users == nil then
  users = {
    admin = "admin"
  }
end

local function authenticate(tokenType, token, user)
  local accessPermitted = false
  if tokenType == "anonymous" then
    tracep(false, 5, "Anonymous token")
    accessPermitted = true
  elseif tokenType == "username" then
    tracep(false, 5, string.format("Checking user name '%s' and password.", user))
    local password = users[user]
    if password ~= nil and token == password then
      accessPermitted = true
    end
  elseif tokenType == "x509" then
    tracep(false, 5, "Checking user certificate.")
    local cert = ba.parsecert(token)
    -- if cert ~= nil and makoConf.users[cert.subject.commonname] ~= nil then
    if cert ~= nil then
      tracep(false, 5, "x509 certificate commom name: ", cert.subject.commonname)
      accessPermitted = true
    end
  end

  if accessPermitted then
    tracep(false, 5, "Access permitted")
  else
    tracep(false, 5, "Access denied")
  end

  return accessPermitted
end

uaServers = {}
local serverConfigs = makoConf and makoConf.uaServers
-- if need to disable OPCUA server then set 'uaServer' to false
-- in mako.conf file
if serverConfigs == false then
  tracep(false, 5, "OPCUA server diasabled in mako.conf file")
  serverConfigs = {}
elseif serverConfigs == nil then
  tracep(false, 5, "Loading OPCUA server configuration from .opcua_server_config.lua")
  local config = _ENV.app.io:dofile(".opcua_server_config", _ENV)
  serverConfigs = config
end

for _, serverConfig in ipairs(serverConfigs) do
  tracep(false, 5, "Start OPCUA server")

  serverConfig.authenticate = authenticate

  -- Create HTTP and HTTPS endpoints since we don't know hostname before server is started
  -- if endpoint URL has only scheme then add hostname, port and http directory
  for _, endpoint in ipairs(serverConfig.endpoints) do
    local endpointUrl = endpoint.endpointUrl
    if endpointUrl == "http://" or endpointUrl == "opc.http://" then
      endpointUrl = string.format("%s%s:%d/%s", endpointUrl, hostname, mako and mako.port or 80, _ENV.dir:baseuri())
    elseif endpointUrl == "https://" or endpointUrl == "opc.https://" then
      endpointUrl = string.format("%s%s:%d/%s", endpointUrl, hostname, mako and mako.sslport or 443, _ENV.dir:baseuri())
    elseif endpointUrl == "opc.tcp://" then
      endpointUrl = string.format("%s%s:%d", endpointUrl, hostname, endpoint.listenPort or "4841")
    else
      endpointUrl = nil
    end

    if endpointUrl and serverConfig.httpDirName then
      endpointUrl = string.format("%s/%s", endpointUrl, serverConfig.httpDirName)
    end

    if endpointUrl then
      endpoint.endpointUrl = endpointUrl
    end
  end

  -- if server certificate not specified then generate one
  if not serverConfig.certificate then
    local certPath, keyPath, certIo = genOPCUACert(init.genServerCertificate, hostname, serverConfig.applicationUri, "opcua_server")
    serverConfig.certificate = certPath
    serverConfig.key = keyPath
    serverConfig.io = certIo
  end

  -- Check server configuration and expand all options
  checkConfig.server(serverConfig)

  local ok, uaServer = pcall(ua.newServer, serverConfig)
  if not ok then
    tracep(false, 5, "Error: server too old for OPCUA example: "..uaServer)
    return
  end

  local function demoAddon(services)
    local objects = "i=85"
    io:dofile(".add_variables.lua")(services, objects)
  end

  uaServer:initialize(demoAddon)
  uaServer:run()
  table.insert(uaServers, uaServer)
end

onunload = function()
  for i, uaServer in ipairs(uaServers) do
    tracep(false, 5, "Stopping OPC-UA server "..i.."...")
    uaServer:shutdown()
    tracep(false, 5, "OPC-UA server "..i.." stopped")
  end
end

_G.uaServers = uaServers

tracep(false, 5, "OPCUA ready")
